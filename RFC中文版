网络组												诺基亚研发中心 C. Perkins
RFC：3561								加州大学圣芭芭拉分校 E. Belding-Royer
类别：试验版							                辛辛那提大学 S. Das
																2003年7月
                                                            

Ad hoc网络中基于距离数组的按需 (AODV)路由协议

本备忘状态

	本备忘定义的只是一个试验性质的网络社区协议而已，它不是任何一种类型的网络标准。我们非常需要各种讨论和建议用于改进这个协议。本备忘录的分发不受任何限制。

版权声明

	复制权属于整个因特网社区，保留所有权利。

摘要

	本协议用于特定网络中的可移动节点。它能在动态变化的点对点网络中确定一条到目的地的路由，并且具有接入速度快，计算量小，内存占用低，网络负荷轻等特点。它采用目的序列号来确保在任何时候都不会出现回环（甚至在路由控制信息出现异常的时候也是如此），避免了传统的距离数组协议中会出现的很多问题（比如无穷计数问题）。

目录

1.
导言

AODV算法旨在多个移动节点中建立和维护一个动态的，自启动的，多跳路由的专属网络。AODV使得移动节点能快速获得通向新的目的节点的路由，并且节点仅需要维护通向它信号所及范围内的节点的路由，更远的节点的路由信息则不需要维护。网络中连接的断开和异动会使得网络拓扑结构发生变化，AODV使得移动节点能适时对这种变化做出响应。AODV的操作是无自环的，并且由于解决了Bellman-Ford“无穷计数”的问题，使得该算法在网络拓扑变化时（比如一个节点在网络中移动）能够快速收敛。当一个连接断开时，AODV会告知所有受到影响的节点，这些节点会让用到这个连接的路由失效。

    AODV的一个显著特点是它在每个路由表项上使用了目的序列号。目的序列号由目的节点创建，并且被包含在路由信息中，然后这些路由信息将被回发到所有向它发起请求的节点。目的序列号的使用确保了无回环，并且易于编程。如果到一个目的有两条路由可供选择，那么收到请求的节点将会选择序列号最大的那一条（由于目的节点每次收到新的请求都会将目的序列号加一，所以序列号最大表明该路由最新）。

2.概述

路由请求（RREQ），路由回复（RREP）和路由错误（RERR）是AODV定义的三种消息种类。这些消息通过UDP和通常的IP协议来接收。举个例子，发起请求的节点需要用它自己的IP地址作为消息中的Originator IP address（发起者IP）。对于广播，将采用IP协议指定的广播地址（255.255.255.255），这个地址意味着这种消息将不会被盲目转发。但是，AODV操作确实要求特定的消息（例如RREQ）得到广泛的散布，甚至有可能散布至整个专有网络。这些RREQ的散布的范围由IP头中的TTL来指定。作为一个特点，将不会采用IP协议中的分片传输。
只要一条通道连接的两个端点都有通向对方的正确路由，AODV是不工作的。当某节点需要连接到一个新的目的节点时，它将广播一个RREQ（路由请求消息）来尝试找到一条到目的节点的路由。如果RREQ消息到达目的节点，这条路由将被找到。另外一种情况下，路由也可以找到，就是RREQ到达了一个中间节点，该中间节点拥有到目的节点的“足够新鲜”的路由。“足够新鲜”的路由首先要是一条到目的地的正确路由，该路由还需要拥有一个足够大的序列号，该序列号不得小于RREQ中的序列号（A ‘fresh enough’ route is a valid route entry for the destination whose associated sequence number is at least as great as that contained in the RREQ.）。当朝发起RREQ的节点单播一个RREP后，这条路由就建立了。所有接到请求的节点都会缓存一条回到发起节点的路由，所以RREP就可以通过单播从目的节点返回到发起节点，或者从一个能够找到目的节点的中间节点返回到发起节点。
节点将相邻节点（next hops）的连接状态保存在活动路由表里（active routes）。当活动路由表里有一条连接断开时，一条RERR消息（路由错误消息）将被用来通知其他节点发生了连接断裂。RERR消息指出了不再能到达的目的节点（甚至是目的子网）。为了实现这种报告机制，每个节点还要维护一个“先驱表”（precursor list），表中包含了一些邻居的IP，这些邻居可能会将它用作达到目的地的下一跳节点。先驱表里的信息可以很轻易的从回传RREP的过程中获得，因为按照定义，RREP就该是传往先驱节点的（见6.6节）。如果RREP有一个非零的前缀长度，那么RREQ的发起者将被包括在先驱表里作为子网的路由。（不是特定的某个精确目的地）。

RREQ也可以用来请求多播地址。这篇文档将不细述这种类型消息处理的全过程（比如这种请求的发起者必须要遵循的某种特别的规则）。但是，使中继节点能正确处理多播操作是非常重要的，特别网络中有没有做过发起节点或目的节点的中继节点，或类似的没有安装任何对多播有特殊操作的节点。考虑到有这种“对多播不感冒”的节点，处理多播目的IP地址必须要和处理其他任何IP地址是一样的操作才行。
AODV是一个路由协议，它的工作就是管理路由表。即使是短期的路由，也必须保留它在路由表里的信息。比如为RREQ临时存储的返回路径。AODV的每个路由表项将会包含下列的域：

- 目的节点IP地址
- 目的节点序列号
- 目的节点序列号是否正确的标志
- 其他状态和路由标志（比如，有效，无效，可修复，正在修复）
- 网络接口
- 跳数（到达目的节点需要的跳数）
- 下一跳
- 先驱表（在6.2节里描述）
- 生命（路由过期或应当删除的时间）

管理序列号对避免路由回环至关重要，即使是当连接断裂，一个节点不再可达而无法提供他自己的序列号信息的时候也是如此。当一条链路断开或失效，导致一个节点不可达，当这种情况发生时，将通过对序列号的操作和标注路由表项为不正确来使得这条路由失效。细节请见6.1节。

3.AODV术语

按照惯例，本协议的说明使用全大写的单词，比如MUST，SHOULD等等来指出对协议各项特性的要求级别（参考文献1）。参考文献3中没有定义的其他术语，在这一节定义如下：（注，汉语中MUST会翻译为必须，SHOULD翻译为应当）

    Active route（活跃路由）

路由表项里标为“有效”（valid）的通向目的节点的路由。只有活跃路由能用来转发数据包。

	Broadcast （广播）

广播的意思是向IP协议规定的广播地址255.255.255.255发送数据。广播的包不会被盲目的转发。但是广播在让AODV消息散布到整个专有网络的时候非常有用。

	Destination （目的地）
		
	数据包需要被送往的一个IP地址。和“目的节点”是同一个意思。当一个节点看到它自己的IP地址和数据包IP头特定的字段中的IP地址一样时，它就认为自己是这个数据包的目的节点。到达目的节点的路由可以从AODV协议得到，AODV协议会在路由发现消息里得到路由信息。

	Forwarding node （转发节点）

愿意为其他节点转发数据包的节点。转发节点会将数据包发送到它的下一个节点（就是在到达目的节点的路径上更靠近目的的那个相邻节点，这条路径由路由控制消息来建立）。

	Invalid route （无效路由）

一个过期的，在路由表项里被标记为无效（invalid）的路由。当一个有效路由失效时，它会作为无效路由在路由表里再被保存一段时间。无效路由不能用于转发数据包，但是它能在路由修复和以后的RREQ消息中提供一些有用信息。

	Originating node （发起节点）

Ad hoc网络内发出AODV路由发现消息的节点。AODV路由发现消息需要被恰当的处理，然后会被传送到网络内其他节点。例如，一个RREQ消息的发起节点就是发起一个路由发现过程并且将RREQ消息广播出去的那个节点。

	Reverse route （返回路由）

用于转发回复包的路由，这个回复包就是从目的节点或能达到目的节点的中间节点返回到发起节点的RREP包。

	Sequence number （序列号）

一个单调递增的数字，由每个发起节点管理。在AODV路由协议的消息里，这个序列号被其他节点用于检测发起节点发出的信息的新旧程度。

	Valid route （有效路由）
		
		见Active route（活跃路由）。
4.适用性综述

AODV路由协议被设计用于拥有数十个到上千个移动节点的Ad hoc网络。AODV能应付低速，中等速度，以及相对高速的移动速度，以及各种级别的数据通信。AODV被设计用于节点间可以互相信任的网络，比如预先定义好密钥的网络，或者是确信不会有恶意入侵节点的网络。为了提升可测量性和效能，AODV设计成尽力减低控制信息的流量，并且消除数据流量的影响（原文：AODV has been designed to reduce the dissemination of control traffic and eliminate overhead on data traffic, in order to improve scalability and performance）。

5.消息格式

5.1.路由请求（RREQ）消息格式

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |  Type (种类)  |J|R|G|D|U|   Reserved (保留)   |Hop Count(跳数)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    RREQ ID (路由请求消息标识)                 |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |          Destination IP Address (目标节点IP地址)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Destination Sequence Number (目标节点序列号)          |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |           Originator IP Address (发起节点IP地址)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Originator Sequence Number (发起节点序列号)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

路由请求消息的格式如上所示，包含下面几个域（或字段）：

Type（种类）		1

J				Join flag （加入标志）：为多播保留

R				Repair flag （修复标志）： 为多播保留

G		Gratuitous RREP flag （免费路由回复标志）： 指示是否该向目标节点IP地址域指定的节点发送一个免费路由回复消息。

D		Destination only flag （仅允许目的节点回复标志）：标志置位则仅允许目的节点回复本条路由请求。

U		Unknown sequence number （未知序列号）： 指示目标节点序列号未知（见6.5节）

Reserved			Sent as 0 （填充0）： 接收端忽略此字段

Hop Count		从发起节点到处理该请求的节点的跳数。

RREQ ID （路由请求标识）	这是一个序列号，用它和发起节点的IP就可以唯一标识一个RREQ信息。

Destination IP Address （目标节点IP地址）
	目的节点的IP地址，本RREQ消息的任务就是想在发起节点和目的节点之间建立一条路由。

Destination Sequence Number （目标节点序列号）
	发起节点在以前通往目标节点的路由信息中能找到的最新的序列号。

Originator IP Address （发起节点IP地址）
	发起本条路由请求消息的节点的IP地址。

Originator Sequence Number （发起节点序列号）
	指向发起者的路由表项中正在使用的序列号。

5.2.路由回复（RREP）消息格式

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |R|A|    Reserved     |Prefix Sz|   Hop Count   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Destination IP address                    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                  Destination Sequence Number                  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                    Originator IP address                      |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |                     Lifetime 生命期                           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

路由回复消息的格式如上所示，包含下面几个域（或字段）：

Type			2

R			Repair flag 修复标志；用于多播

A			Acknowledgment required 需要确认；见5.4节和6.7节。

Reserved		Sent as 0 填充0； 接收时忽略此字段。

Prefix Size		前缀长度。这个字段为5个bit（值为0到31），如果非0，则代表下一跳节点可以作为任何具有相同路由前缀的节点被请求时的目的节点。这个“相同路由前缀”就是Prefix Size定义的前缀。

Hop Count	从发起节点到目标节点的跳数。对多播路由请求，这个跳数则是从发起节点到多播节点组里产生RREP信息的节点的跳数。

Destination IP Address
	目标节点的IP地址，一条路由将提供给这个节点。

Destination Sequence Number
	和这条路由联系在一起的目标序列号

Originator IP Address
	发起RREQ消息的节点的IP地址，路由将被提供给这个节点。

Lifetime	路由生命时间，单位为毫秒。在这段时间内，接收RREP的节点会认为这条路由是有效的。

    注意到Prefix Size（前缀长度）使得一个子网的路由器能够为子网内所有的主机提供路由信息，而这个所谓的“子网”则是由路由前缀来定义的。路由前缀由子网路由器和前缀长度共同决定。（比如192.168.3就是一个长度为24的路由前缀，那么所有以192.168.3开头的IP就属于同一个子网——译者注）。为了让这个特性发挥作用，子网路由器必须保证它和其他所有具有相同子网前缀的主机都是可达的。详情请参考第7节。当前缀长度非零时，所有的路由信息（包括先驱信息）都必须遵循子网路由，而不是单独的包含子网内目的主机的地址。


5.3.路由错误（RERR）消息格式

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |N|          Reserved           |   DestCount   |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |            Unreachable Destination IP Address (1)             |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |         Unreachable Destination Sequence Number (1)           |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-|
   |  Additional Unreachable Destination IP Addresses (if needed)  |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |Additional Unreachable Destination Sequence Numbers (if needed)|
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

路由错误消息的格式如上所示，包含下面几个域（或字段）：

Type			类型，RERR的此字段为3

N		No delete flag 不必删除标志；当一个节点已经对这条连接作了本地修复时，这个标志位置位，这样上游的节点就不用删除这条路由。

Reserved	保留字段，填充0，接收端不作处理。

DestCount	本消息内包含的不可达目的节点的数目，必须至少为1.

Unreachable Destination IP Address
	因为连接断开而不可达的目的节点的IP地址。

Unreachable Destination Sequence Number
	路由表项里不可达目的节点的序列号。这个不可达节点的IP就是上面那个Unreachable Destination IP Address。

当一条连接断开导致一个或多个节点不可达时，RERR消息就会被发出。关于如何维护连接断开产生的记录，请见6.2节；如何建立目的节点列表的详细说明请见6.11节。

5.4.路由回复确认（RREP-ACK）消息格式

当收到一条’A’位（‘需要确认’位）被置位的RREP消息时，必须回发一条路由回复确认消息作为响应。当网络中存在单向连接而导致路由发现的往返过程（见6.8节）无法完成时，这是一个典型的操作。

    0                   1
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     Type      |   Reserved    |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

      Type        消息种类标志，RREP-ACK消息的这个标志是4

      Reserved    填充0; 接收时忽略。

6.AODV操作

在本部分所描述的场景里，对于有某一特定目的地址的单播通信，节点生成了Route Request（RREQ），Route Reply（RREP）和Route Error （RERR）三种信息，并且还要决定如何处理这些消息。为了正确处理这些消息并考虑到目的节点，在路由表项中需要维护某种特定的状态信息。

所有的AODV消息都要发送到654端口，并且使用UDP协议。

6.1.管理序列号

每一个节点的每一个路由表项必须包含关于目的节点（路由表就是为此而维护的）IP地址的序列号的最新可用信息。这个序列号叫做“目的序列号”。如果在任何时候一个节点接收到了新的（即未失效的）信息，而这个信息是跟RREQ，RREP，或者RERR消息（这些消息跟目的节点可能有关系）中的序列号有关的话，目的序列号就会更新。AODV要求在网络中的每一个节点都要拥有并维护其目的序列号，以保证朝向这个目的节点的所有路由路径都是无环路的。在两种情况下，目的节点会增加它自己的序列号：

-	在一个节点发起一个路径发现的请求之前，他必须增加它自己的序列号。这样，对于已经建立好了的朝向RREQ消息发起者的反向路由来说，可以防止本次请求与其相冲突。

-	在目的节点生成RREP消息以响应RREQ消息之前，它必须更新它自己的序列号，新的值是它目前的序列号和RREQ消息包中目的序列号的较大者。

当目的节点要增加它的序列号时，它必须以无符号数的形式来处理序列号。为了完成序列号的循环轮转，如果序列号已经达到了32位无符号整型变量所能达到的最大可能值（也就是4294967295），那么当它再增加时，这个数字将会变成0。另一方面，如果序列号目前是2147483647——也就是32位以2的补码形式表示的最大可能值——下一个数字将会是2147483648，这是在此计数系统下的负数最大可能值。负数的表示形式跟AODV序列号的增加无关。比较两个需要处理的AODV序列号时的做法跟此正好相反（见下面）。

为了确定目的节点的信息是否是新的，当前节点会拿自己目前的序列号数跟接收到的AODV信息中的序列号数相比较。这个比较必须使用32位有符号数，它对于完成序列号循环轮转是必须的。如果从接收到的序列号数减去当前序列号的结果小于0的话，那么这个接收到的有关目的节点的AODV信息就必须被丢弃，因为跟节点当前所保存的信息相比，接收到的信息更加陈旧。

另外，节点为了修复路由路径中丢失了的或者过期了的下一跳时，可能会改变其路由表项中的目的序列号，这也是除了以上情况以外唯一要改变目的序列号的情况。节点通过查询其路由表来查询都有哪些目的节点使用了这个不可使用的下一跳节点。在这种情况下，对于每一个使用这个节点的目的节点，当前节点都会增加其序列号并把此路径标记为不可用（并见3.11，6.12部分）。一旦节点接收到了一个足够新的（也就是包含大于等于本节点所记录的序号），并且是来自于已经标记相应路由表项为不可用的节点的路由信息时，当前节点应该以新的信息来更新其路由表信息。



节点需要改变目的路由表项中的序列号，当以下情况发生时：

-	它自己就是目的节点，并且提供了一个到它自己的新的路由，或者

-	它接收到了一个拥有关于目的节点序列号的新信息的AODV消息，或者

-	朝向目的节点的路径过期了或者崩溃了。

6.2.路由表项和先驱列表

当一个节点从它的邻居接收到一条AODV控制包时，以及为某个特定的目的节点或目的子网创建或更新它的路由表的时候，它就会去检查它的路由表里是否有一个表项对应到那个目的。当没有相关的表项时，新的表项就会被创建。序列号要么就是从AODV控制消息里提取的，要么就干脆在路由表项里“序列号有效”这个位置标明“无效”。仅在新的序列号满足下列三种条件时路由会更新：

(i)新序列号要比路由表里原来的原目的序列号大。

(ii)序列号相等，但是新信息里包含的跳数加一还要比原来的跳数小。

(iii)新序列号是未知的。

路由表里的“有效期”要么从控制包里得到，要么设置为ACTIVE_ROUTE_TIMEOUT（有效路由超时）。这条路由现在就可以用作发送数据包，并且能满足其他的路由请求。

每当一条路由被用来转发一个数据包时，它里面源、目的和下一条节点的“路由有效期”这一项会被更新，新的值不小于当前时间加上ACTIVE_ROUTE_TIMEOUT。由于每对发起节点和目的节点之间的路由应当是对称的，每个节点的上一跳的路由有效期（即回到发起节点路径上的下一个节点）也会被更新为不小于当前时间加上ACTIVE_ROUTE_TIMEOUT。不管目的是单个的节点还是一个子网，每当路由被用到的时候，路由有效期都会被更新。

对每个放在路由表项里的有效路由，节点还会维护一张先驱表，这些先驱可能会沿着这条路由转发数据包。当检测到下一跳断开时，这些先驱就会从本节点收到通知。路由表项里的先驱列表包含的是都是本节点的相邻节点，路由回复信息将会被发送到这些节点。

6.3.生成路由请求

当一个节点无法找到一个可用的到某个节点的路由时，它就会广播一条RREQ消息。出现这种情况可能是由于这个节点以前并不知道有这么一个目的节点，也可能是由于以前到该目的节点的有效路由过期了，或是被标记为无效。RREQ消息的“Destination Sequence Number”这个域应当填最近一次获得的该节点的目的节点序列号，这个序列号直接就从路由表里的“Destination Sequence Number”域复制过去。如果尚未获得任何目的节点序列号，则“序列号未知”标志必须被置位。RREQ里的“Originator Sequence Number”就是发起节点自己的序列号，在把它放入RREQ消息里时，它得先自增1。消息里“RREQ ID”则是将当前节点以前用过的RREQ ID加一。每个节点只维护一个RREQ ID。“Hop Count”填0。

在广播RREQ消息之前，发起节点会将消息的RREQ ID和Originator IP address（就是它自己的IP地址）缓存一段时间，这个时间由“PATH_DISCOVERY_TIME”来决定。这样，当这个节点从邻居那里收到具有相同RREQ ID和Originator IP address的RREQ消息时，它将会认为这是一个发回来的包而将它丢弃。

一个发起节点总是想和目的节点建立双向的通信，即，仅仅是发起节点有到目的节点的路由还不够，目的节点还必须拥有回到发起节点的路由。为了尽力有效的实现这个特性，每个中间节点在生成RREP回发给发起节点的同时（见6.6节），还必须执行某种操作，用于告知目的节点一条返回发起节点的路由。当发起节点需要让中间节点作出上述操作的时候，它需要将RREQ的“G”标志位置位（Gratuitous RREP flag 免费路由回复标志）。有关中间节点如何处理带“G”标志位的RREQ消息的细节，请见6.6.3节。

一个节点每秒钟发出的RREQ消息数目受到RREQ_RATELIMIT的限制，当广播出去一个RREQ消息后，它会等待RREP消息（或其他带有目的节点的当前路由信息的控制消息）。如果路由信息在NET_TRAVERSAL_TIME毫秒内还没被收到，这个节点就可以尝试着发送一个新的RREQ消息来再次寻找路由。最多可以以最大的TTL值发送RREQ_RETRIES次请求。每次发送新的RREQ都必须将RREQ ID加一。IP头里的TTL值由6.4节描述的法则来确定，用来控制RREQ消息的散布范围。

等待路由的数据包（比如在送出RREQ消息后还在等待RREP消息）应当被存在缓冲区里。缓冲应当遵循“先进先出”原则。如果一个路由寻找过程已经在最大的TTL值下尝试了RREQ_RETRIES次而还没有收到RREP时，所有被缓冲的送往这个目的的数据包都应当被丢弃，并且还应当向应用程序回送一个“目的不可达”消息。

为减少网络拥塞，源节点向单个目的节点建立连接的尝试必须遵从二的幂次递减原则。当节点第一次广播一个RREQ消息时，它会等待NET_TRAVERSAL_TIME毫秒来接收RREP消息。如果在这段时间内RREP没有到达，源节点就会送出一个新的RREQ。第二个RREQ的回复消息RREP的等待时间就应当遵从二的幂次递减原则，也就是，这个等待时间应该为2×NET_TRAVERSAL_TIME毫秒。如果在这段时间内RREP消息仍然没到，另一个RREQ就又可以送出去了。在第一个RREQ消息发出去以后，最多还可以再尝试RREQ_RETRIES次。对每一次的尝试，它的等待时间都应当是上一次尝试时间的2倍。这样就从等待时间上保证遵从了网络协议的二的幂次递减原则。

6.4.控制路由请求消息的传播

    为了防止RREQ消息在整个网络内散布得到处都是，发起节点应当逐次的扩大搜索范围。在范围逐次扩大的搜索中，发起节点最初会设置RREQ包的IP头内的TTL值为TTL_START，设置等待RREP的超时时间为RING_TRAVERSAL_TIME毫秒。RING_TRAVERSAL_TIME的计算方法会在第10节描述。用于计算RING_TRAVERSAL_TIME的TTL_VALUE的值被设置成等于IP头中的TTL值。如果发出RREQ后等待RREP超时，发起节点将再次广播RREQ，而这次的TTL值将被加上TTL_INCREMENT。这样一直持续到RREQ包内的TTL达到阈值TTL_THRESHOLD。在达到阈值后，每次使用的TTL都将被设置为NET_DIAMETER。每次等待RREP的超时时间都是RING_TRAVERSAL_TIME。如果需要每次路由寻找都在整个Ad Hoc网络范围内进行，可以将TTL_START和TTL_INCREMENT都设置为等于NET_DIAMETER来达到目的。

在一条失效的路由表项里存储的跳数（Hop Count）代表的是最后一次获得的到目的节点的跳数。如果又需要新建一条到达该目的节点的路由（比如路由丢失的情况），发出的RREQ的IP头内的TTL值将会被设置成这个失效的跳数加上TTL_INCREMENT。从这以后的每次超时，TTL都将增加TTL_INCREMENT，直到TTL等于TTL_THRESHOLD，在此以后，TTL将等于NET_DIAMETER。一旦TTL等于NET_DIAMETER，等待RREP的超时时间就将被设置成NET_TRAVERSAL_TIME，就像在6.3节里被讨论的那样。

一条失效的路由表项仍然需要在路由表里保存到当前时刻加上擦除时间（current_time + DELETE_PERIOD），在此期间不应当被擦除（见6.11节）。否则，和这条路由有关的软件信息（比如失效前最后一次获得的跳数Hop Count）就会丢失。此外，还可以将路由表项从失效到被擦除的时间配置得更长一些。任何正在等待RREP的路由表项都不应当在（current_time + 2×NET_TRAVERSAL_TIME）这个时刻之前被擦除掉。

6.5.处理和转发路由请求

当一个节点收到一条RREQ消息时，它首先创建一个到前一跳节点的路由，或者更新原来已有的，但序列号不对的到上一跳的路由（见6.2节）。然后检查它在PATH_DISCOVERY_TIME时间内是否受到过具有相同Originator IP Address和RREQ ID的RREQ消息。如果已经接收过了，那么这个节点就会丢弃这个RREQ，不作任何操作。这一节的余下部分将讨论对没有丢弃的RREQ请求该如何处理。

首先，该节点会将RREQ消息内的跳数加一，表明该RREQ又跳过了一个中间节点。然后该节点会搜索到发起节点IP地址的反向路由（见6.2节），使用的是最长前缀匹配法。如果有必要，这条路由会被创建，或者用RREQ消息内的Originator Sequence Number来更新。当该节点接收到一条RREP需要回传到发起节点时，这条路由就会被用到（RREP消息送达的目的如果和RREQ消息内的Originator IP Address一样，则说明这条RREP消息是对该RREQ的回复，于是在接收RREQ时创建的反向路由就可以被用到了）。当反向路由被创建或更新时，将对它执行以下操作。

1.RREQ消息内的Originator Sequence Number（发起节点序列号）会被用来和反向路由里对应的目的节点序列号比较，如果比已经在路由表里的那个大，那么就会被复制到路由表里面。

2.路由表项里“序列号有效”一栏会被设置为“有效”

3.反向路由表项里的“下一跳”将被设置为传递RREQ给本节点的那个相邻节点（这个地址就是RREQ数据包IP头内的源IP地址，且大多数情况下它并不等于RREQ消息内的发起节点地址）

4.反向路由表项里“跳数”直接从RREQ消息内的“跳数”复制而来。

每当接收到一条RREQ消息时，指向发起节点IP地址的反向路由的有效期将被设置为ExistingLifetime和MinimalLifetime中的较大者。这里：

MinimalLifetime =		(current time + 2×NET_TRAVERSAL_TIME –
					2×HopCount×NODE_TRAVERSAL_TIME)

节点可以用这条反向路由来转发其他路由的数据包，只要它们走的路径相同。

如果一个节点不生成RREP消息（按照6.6节的处理规则来生成），并且接收到的RREQ包IP头里的TTL大于1，那么这个节点就将更新这条RREQ消息并且在它的每个网络接口上向255.255.255.255广播这个RREQ消息（见6.14节）。对RREQ做的更新是：IP头内TTL或者跳数限制将被减一，RREQ消息内的“跳数”则将被加一，用于对新的一跳计数。最后，Destination Sequence number这一栏将被设置为RREQ消息内对应值和节点本身维护的目的节点序列号之间的大者。但是，转发节点一定不能修改它维护的目的节点序列号，即使接收到的RREQ消息内的这个序列号比当前维护的值要大也不行。

反之，如果一个节点生成RREP消息，那么它就会丢弃掉RREQ。注意，如果中间节点对送往特定目的节点的RREQ的每一次传递都作出回复的话，可能会导致目的节点收不到任何路由发现信息（有可能其他节点收到了RREQ，而它知道一条到目的节点的路由，于是它就会发回一个RREP，同时丢弃掉RREQ，这样，目的节点就会这次路由发现过程毫不知情——译者注）。在这种情况下，目的节点不会从RREQ消息上获得通往发起节点的路由。而这可能会导致目的节点发起一个到发起节点的路由发现过程（例如，如果发起节点试图和目的节点建立一个TCP连接的情况）。为了使目的节点也能得到返回发起节点的路由，不管是出于什么原因，只要觉得目的节点需要一条返回路由，发起节点就应当将RREQ消息内的“Gratuitous RREP”标志位（G）置位。如果一个中间节点为响应一条带“G”标志的RREQ而向发起节点回复了一个RREP，那么它也必须免费向目的节点送出一条RREP消息。（见6.6.3节）。

6.6.生成路由回复

一个节点在下面两种情况下会生成一条路由回复消息：

(i)它自己就是目标节点。

(ii)它到目的节点有一条有效路由，且路由表项内的目的节点序列号有效并且不小于RREQ消息内的目的节点序列号（以32位有符号数的格式进行比较），且RREQ内的“仅目的节点回复”标志位（D）未被置位。

当生成一条RREP消息时，节点会将RREQ消息内的目的节点IP地址和发起节点序列号拷贝到RREP的相应区域内。对上面列出的两种情况，处理过程稍有不同，可以分别参考6.6.1节和6.6.2节。

一旦被创建，RREP消息就将被送往通向发起节点的下一跳节点，这个节点由路由表里通向发起节点的路由表项给出。当RREP被转发回发起节点时，它里面的“跳数”每一跳都会加一，这样，当RREP到达发起节点时，这个跳数应当和发起节点到目的节点的跳数一致。

6.6.1.目标节点路由回复的生成
如果路由的生成节点就是目标节点，且RREQ包中的序列号等于递增值，该节点必须让自身的序列号加一。否则，目标节点不会在生成RREP包以前改变它的序列号。目标节点把它的序列号（可能是新增加过的）放到RREP的序列号段中，并在RREP 的跳数段中置0。

目标节点拷贝MY_ROUTE_TIMEOUT的值（见节10 ）到RREP的生命期字段中 。每个节点都可以在一定的限制下重新配置MY_ROUTE_TIMEOUT的值（见节10 ） 。

6.6.2.中继节点路由回复的生成
如果生成RREP的节点不是目的节点，而是从发端到目的节点路径上的一个中间跳点，它将拷贝它所知的目的节点的序列号到RREP的目的节点字段。

中继节点通过把最后跳过的节点（从收到RREQ中IP报头源IP地址段中可得到）加入了前向路由表项的先驱表，更新了前向路由表项--即目的I P 地址的入口。中继节点为逆推路由表项通过把向目的节点的下一跳放入先驱表更新了RREQ发生节点的路由表项--即RREQ消息数据中起源IP地址字段的项。

中继节点放置它到目的节点（用跳数在路由表中标识）的跳数到RREP中的Count字段。RREP的Lifetime字段是在路由表项中由满期时间减去当前时间得到的。

6.6.3.生成未被要求的路由回复

当一个节点收到一个RREQ且收到RREP回复之后，它会丢弃掉这个RREQ。如果这个RREQ的G标识位被置位，且中间节点向发起节点返回一个RREP的话，它必须也要单播一个未被要求的RREP到目的节点。这个未被要求的被送到目的节点的RREP在其消息字段包含了以下值：

跳数							跳数在节点的发起节点路由表项中被标识

目的IP地址						发起RREQ的节点的IP地址

目的序列号						来自RREQ的发起节点中的序列号

发起节点IP地址					RREQ中目的节点的IP地址

生存期		中间节点所知的从RREQ的发起节点开始的路由剩余生存期

6.7.接受和转发路由回复

当一个节点收到RREP讯息，它将搜索（使用最长前缀匹配）到前一跳的路由。如果需如若需要，将为前一跳建立起一个没有有效序列号的路由（见6.2 ）。然后考虑到新的跳跃通过此中继节点，该节点在RREP中的跳数值加一。这个增加后的值称作“新跳数” 。  然后如果到目的节点的前向路由不存在，则建立此路由。否则，该节点将消息中的目的序列号与它在RREP中为目的IP所存储的目的节点序列号相比较。经比较， 存在的条目被更新只有下列几种情况：

   (i)       路由表中的序列号在路由表向中被标识为无效。

   (ii)      RREP中的目的序列号大于目的序列号在此节点的副本且已知值是有效的，or


   (iii)     序列号是相同的，但路由标示为无效，or

   (iv)      序列号是相同的，且新的跳数小于路由表项中的跳数。

若到目的节点的路由表项被创造或更新，将发生下面的操作：

   -  此路由被标识为活动,

   -  此目标序列号被标识为有效,

   -  路由表项中的下一跳被指定为在收到的RREP的IP头的源IP地址段所指出的节点。

   -  跳数被被更新。

   -  路由过期时间被设置为当前时间加上RREP信息中的生命期。

-  目的序列号取RREP中的目的序列号。

当前节点可以随后使用这个路由来发送数据包到目的节点。

如果当前节点不是源IP地址在RREP消息中标识的节点，且一个前向路由如上所述被创建或更新，这个节点征询它的路由表项，以使源节点为RREP包决定下一跳，然后使用路由表项中的信息向源节点发送RREP包。如果一个节点通过以上链接转发一个可能出错或是单向的RREP，这个节点应该将“A”标志位置位以指示此RREP包的接受者送回以个RREP-ACK包确认已接受到该包。（见节6.8）

当任何节点发送了一个RREP,符合目的节点的先驱表中加入下一跳节点以被更新，其RREP被转发。此外，在（逆向）路由的每个用来转发RREP包的节点上将其生命期改为(existing-lifetime, (current time +ACTIVE_ROUTE_TIMEOUT)的最大值。最后，向目的节点的下一跳的先驱表被更新，使其包含朝向源节点的下一跳。

6.8.对单向连接的操作

很有可能的是，RREP传输可能会失败，特别是如果RREQ传输触发RREP通过了一个单向链接。如果没有从同样的已知路由产生的其它RREP试图到达生成RREQ信息的源节点，源节点将在超时后重新尝试发现路由（见节6.3）。然而，同样的情景很可能重复没有任何改善，经历了再三重复也没有路由被发现。即使发起节点和目的节点之间的双向路由确实存在，这也很可能发生，除非采取纠正行动。采用广播传输RREQ的链路层将无法检测到存在这种单向链路。在AODV协议中，任何节点只对第一个带有相同RREQ ID的 RREQ包起作用并忽略其它随后的RREQ包。我们设想，例如，第一个RREQ沿着一条有一个或多个单向链接的路径到达。一个随后的RREQ可能通过一个双向路径（假设存在这样的路径）到达，但它会被忽略。

要避免这个问题，当一个节点检测到它传送的RREP失败，它将把失效RREP的下一跳记入“黑名单”设置。这些失败可以不通过链路层或者网络层的承认（如，RREP-ACK）。节点将无视所有在其黑名单设置中发送的RREQ。节点在BLACKLIST_TIMEOUT时间后，将从黑名单设置中被移除（见节10）。这个时间应设置为执行允许数量的路由请求重新尝试的时间上限，见节6.3。

请注意，RREP-ACK包并不包含任何有关此RREP是否得到承认的信息。可能紧随带“A”标识的RREP包刚发出去，就收到RREP-ACK包。此信息预计将足以向发送方保证RREP的链接目前是双向的，不需要实际依赖于特定RREP被确认。但是，这种保证通常不能指望永远有效。

6.9.Hello消息

一个节点可以通过广播本地Hello消息提供连接信息。如果一个节点是主动路由的一部分，它应该只使用Hello 信息。每经过HELLO_INTERVAL毫秒，节点检查它在过去的HELLO_INTERVAL是否发出了一个广播（例如，一个RREQ包或适当的第2层信息）。如果还没有，它可能播出一个TTL = 1的RREP信息，称为Hello信息，其RREP信息字段设置如下：

      目的IP地址		此节点的IP地址

      目的序列号    		此节点最新的序列号

      跳数	                    0

      生命期                       	ALLOWED_HELLO_LOSS * HELLO_INTERVAL

一个节点可以通过监听临近节点的包确定链接。如果在过去的DELETE_PERIOD，它从临近节点收到了一个Hello信息，然后这个临近节点超过ALLOWED_HELLO_LOSS * HELLO_INTERVAL毫秒都没有收到任何包（Hello信息或其它），这个节点应该断定它与此临近节点的链接已断开。在这种情况下，这个节点应该按节6.11的情况处理。

每当一个节点从临近节点收到一个Hello消息，该节点应该确保它与此临近节点有一条活动的路由，如果有必要则创建一条。 如果一个路由已经存在，那么这条路由的生命期应该增加，如果必要，至少ALLOWED_HELLO_LOSS * HELLO_INTERVAL。这条通往临近节点的路线，如果存在，必须包随后包含Hello信息中最新的目的序列号。当前节点现在可以开始使用这条路线转发数据包。没有被其它活动路径使用的由Hello信息创建的路线将拥有一个空的先驱表，且如果临近节点移走或超时时不会触发RRER信息。

6.10.维护本地连接

每一个转发消息的节点都应该对其与活动下一跳节点（也就是在最近的ACTIVE_ROUTE_TIMEOUT时间内下一跳/前驱节点曾经从转发消息的节点发送/接收过数据包的节点）的连接保持持续的跟踪，也应该对在最近的ALLOWED_HELLO_LOSS * HELLO_INTERVAL时间内曾经发送过Hello消息的邻居节点进行跟踪。通过使用一个或多个可用连接或者网络层的机制，节点可以维护关于其与这些活动下一跳节点之间连接的准确信息。这些机制将在下面说明。
- 任何合适的链接层的通知，比如802.11提供的通知，都可以被用来检测连接状态，每次向下一跳活动节点发送一个数据包。比如，在达到尝试重发的最大数目之后，缺少链接层的ACK或者在发送RTS只有没有收到CTS，这些都能够指出到下一跳连接的缺失。
- 如果层-2（layer-2）通知不可用，当下一跳被期望应该使用监听信道尝试发送数据来转发数据包时，应该使用被动通知。如果在NEXT_HOP_WAIT毫秒内或者下一跳就是目的节点（因此也就不会转发数据包）没有检测到发送数据包的话，下面方法之一就应该被用来检测连接状态：
	* 从下一跳节点接受任何数据包（包括Hello消息）。
	* 向下一跳节点发送RREQ单播消息，询问到下一跳的路由。
* 向下一跳节点单播ICMP Echo请求消息。
如果到下一跳的连接不能被以上任何方法所检测到，那么转发数据包的节点就应该假设连接已经丢失，并按照6.11部分所简述的来采取正确的措施。

6.11.路由错误，路由超时和路由删除
一般来说，路由错误和连接中断处理需要以下步骤：
	- 将现有路由无效化
	- 列出受影响的目的节点
	- 如果有的话，判断哪些邻居节点可能会受到影响
	- 对这些邻居节点发出适当的RERR消息
	路由错误消息或许要么被广播（如果存在多个前驱节点），要么被单播（如果只存在一个前驱节点），要么被反复地单播到所有的前驱节点（如果广播不可用）。即使RERR消息被重复地单播到几个前驱节点时，RERR消息也会被认为是一个单独的控制消息，这个控制消息的目的在以下的文字中有所描述。有了这样的理解之后，一个节点就不应该每秒生成超过RERR_RATELIMIT数量的RERR消息。
	在三种情况下，节点会初始化对于RERR消息的处理：
（i）当传送数据（和尝试路由修复未果）时，如果在节点的路由表中，节点检测到某个活动路由上的下一跳发生了连接中断，或者
（ii）如果节点接收到了一个数据包，其目的地是要到本节点没有活动路由而且也没有修复（如果使用了本地修复），或者
（iii）如果节点从邻居节点接收到了一个或多个活动路由的RERR消息。
对于情况（i），节点首先列出一个不可达目的节点的列表，这个列表包括不可达的邻居节点和本地路由表中使用这些不可达节点作为下一跳的其他目的节点（或者子网，见第7部分）。在这种情况下，如果子网路由被新发现为不可达，则子网的IP目的地址的形式就是在路由表项中的子网前缀后面附加一些零。这是很明确的，因为我们知道前驱节点拥有与那个子网前缀长度兼容的路由表信息。
对于情况（ii），只有一个目的节点是不可达的，也就是数据包不能被传送到的那个节点。对于情况（iii），列表应该由RERR消息中的那些目的节点组成，对于这些目的节点，在本地路由表中都存在一个对应的表项，这些路由表项都以接收到的RERR消息的发送者作为下一跳。
列表中的某些不可达节点可以被作为邻居节点来使用，因此也就必须发送一个（新的）RERR消息。RERR消息应该包含的目的节点是创建的不可达目的节点的列表的一部分，也应该有一个非空的前驱列表。
应该接收RERR消息的邻居节点都是在前驱列表之中的，这个前驱列表是新创建的RERR消息中不可达目的节点之一所创建的。如果只有一个需要接收RERR消息的邻居节点，在这种情况下，RERR消息应该向那个邻居节点单播。否则，很典型地，RERR消息会被发送到本地广播地址（目的节点IP==255.255.255.255，TTL==1），而不可达目的节点和它们对应的目的节点序列数则会包含在数据包里。RERR包中的DestCount域显示的是数据包中不可达目的节点的数目。
在发送RERR消息之前，在路由表中要做某些更新，这些更新可能会影响到不可达节点的目的节点序列数。对于每一个目的节点，对应的路由表项应该按如下更新：
1.这个路由表项的目的节点序列数，如果其存在并可用，对于以上情况（i）和（ii），要增一；对于情况（iii）则要从接收到的RERR消息中拷贝。
2.通过标记路由表项为无效，路由表项被设置为无效了。
3.LifeTime域被更新为当前时间加上DELETE_PERIOD。在此时间之前，此表项不应该被删除。
注意路由表中的LifeTime域扮演着两个角色——对于活动的路由来说，它是超时时间；对于无效路由来说，它是删除时间。如果接收到了一个无效路由的数据包，LifeTime域就被更新为当前时间加上DELETE_PERIOD。DELETE_PERIOD的大小将在第10部分讨论。

6.12.本地修复
当一个活动路由中发生了连接中断时，如果目的节点距离不超过MAX_REPAIR_TTL跳数的话，发生中断位置的上游节点可能会选择在本地将其修复。为了修复连接中断，节点会增加到目的节点的序列数，然后广播一个到目的节点的RREQ消息。这条RREQ消息的TTL域应该被初始化设置为以下的值：
	max(MIN_REPAIR_TTL, 0.5 * #hops) + LOCAL_ADD_TTL
	这里#hops是到目前不可发送的包的发出者（生成者）的跳数。因此，本地修复的尝试对于生成节点常常是不可见的，而且总会有TTL>= MIN_REPAIR_TTL + LOCAL_ADD_TTL。初始化修复了的节点然后要等待发现时期（discovery period）这么长时间以接收响应RREQ消息的RREP消息。在本地修复期间数据包应该被缓存。在发现时期的结束，如果修复节点还没有接收到关于此目的节点的RREP（或者其他创建或者更新路由的控制消息）消息，它就会像6.11节中所描述的步骤来进行处理，即向目标节点发出一个RERR消息。
	另一方面，如果在发现时期内，节点接收到了一个或者更多RREP消息（或者其他朝向所需目的节点的创建或更新路由的控制消息），它首先用新路由的跳数与到目的节点的不可用的路由表项的跳数相比较。如果到目的节点的新路由的跳数比以前所知道的路由的跳数大，节点应该发出一个到目的节点的RERR消息，而且N位要设置为一。然后它按照6.7节所描述的步骤进行处理，即更新其到此目的节点的路由表项。
	接收到带有N标记被设置了的RERR消息的节点，一定不能删除到那个目的节点的路由。如果RERR消息是从此路由上下一跳节点所传来的，而且如果在到目的节点的路由上有一个或多个前驱节点的话，唯一要采取的操作应该是重新发出这条消息。当生成消息的节点接收到了带有N位被设置为一的RERR消息时，如果此消息是从到目的节点路由上的下一跳发过来的话，当前节点就会像6.3节中描述的一样，可能会选择重置路由发现请求。
	路由中的本地节点修复有时会导致到目的节点的路径长度增加。本地修复连接很可能会增加能够到达目的节点的数据包的数量，因为当RERR消息在到生成消息的节点的路上时，数据包不会被扔掉。在本地修复连接中断以后向生成消息的节点发送RERR消息可能会允许生成消息的节点发现一个到目的节点的新路由，这个新路由如果以当前节点的位置来说是更好的。然而，就像生成消息的节点可能已经完成了的或者接近完成了的，这并不需要生成消息的节点用数据会话（data session）来重建路由。
	当一条路由上出现连接中断时，经常会有多个目的节点变得不可达。丢失连接的上游节点会尝试立即执行本地修复，这个本地修复是仅仅朝向数据包前进方向上的那个目标节点而进行的。其他使用同一连接的路由必须被标记为不可达，但是处理本地修复的节点可能会把每个这种新丢失的路由标记为本地可修复的；当路由超时（也就是在ACTIVE_ROUTE_TIMEOUT时间内路由一直是不活动的）的时候，这个路由表中的本地修复标志必须被重置。在超时发生之前，当去往其他目的节点的包到达时，这些其他路由将会按照需要被修复。因此，这些路由是按需修复的；如果对于某条路由的数据包没有到达，那么路由就不会被修复。另外一种方法是，视本地网络拥塞状况，节点可能对其他路由开始进行本地修复的处理，而不等候新的数据包的到达。通过提前修复已经由于连接丢失而中断的路由，这些路由上接收到的数据包将不会受到修复路由所带来的延迟的影响，而能够被立即转发。然而，在数据包到达之前就修复路由可能会有风险，即修复了再也不使用的路由。因此，基于网络中的本地流量和是否正发生网络拥塞，节点可能会选择在数据包接手之前提前修复路由；否则，它会等候到有数据包接收到时，然后再开始路由的修复。


6.13.重启后的操作
在重启以后，ad hoc中的节点必须采取某种操作，因为它可能丢失了到所有目的节点的所有序列数，包括它自己的序列数。但是，可能有邻居节点正在使用这个节点作为活动的下一跳。这就可能潜在地制造环路。为了防止出现这种可能，每一个重启了的节点在发送任何路由发现消息以前，都要等候DELETE_PERIOD时间。如果节点接收了RREQ，RREP或者RERR控制包，它应该以控制包中的序列数信息来创建路由表项，但是一定不能转发任何控制包。如果此节点接收到了到其他目的节点的数据包，它应该像6.11节中所描述的一样广播出RERR消息，而且必须重置等待计数器，此计数器在当前时间加上DELETE_PERIOD后过期。
	[4]中表明，在重启节点度过等待节点并重新变为活动路由时，它的所有邻居都不会再把它当成活动的下一跳了。只要它从其他任何节点接收到了RREQ消息，它自己的序列数都会增加，因为RREQ消息总会带来路由上的最大目的节点序列数。如果没有这种RREQ消息到来，节点必须将它自己的序列数初始化为0。

6.14.接口

由于AODV应该在有线和无线两种情况下均顺畅工作，而且由于AODV很可能会被用在多无线网络器件（multiple wireless devices）上，因此一旦有包到达了，AODV必须要知道包所到达的特定接口。这包括接收RREQ、RREP和RERR消息。一旦接收到了从邻居处发过来的包，接收包的接口就应该同其他应该被记录的路由信息一起，被记录进此邻居对应的路由表项。类似地，一旦知道了到新的目标节点的路由，能够到达此目标节点的接口也应该被记录进目标节点的路由表项。
当多接口可用时，转发RREQ消息的节点会在ad hoc网络中所有已经配置好了的接口上重新广播这条消息，除非已经知道在此接口上的所有邻居节点都已经接收到了此RREQ消息。例如，对于某些广播媒质（也就是网卡）来说，可能会假定在同一连接上的所有节点都会在同时收到一条广播信息。当某个节点需要发送RERR消息时，它应该只在那些对此路由有邻居前驱节点的接口上发送这条消息。
7.AODV和集群网络

设计AODV的目的是供拥有IP地址的移动节点所使用，以建立一个ad hoc网络。这些节点不是必须彼此相连的。然而，在某些情况下，一群移动节点或许会在一个彼此之间关系固定的情况下进行操作，他们拥有一个共同的子网前缀，在一个ad hoc网络的区域内一同移动。我们把这群节点称为一个“子网”。在这种情况下，很可能会出现这种情况，即子网内的一个单独的节点通过使用RREP消息，来应答一个请求到某一子网路由前缀节点的RREQ消息，来广播它到其他所有节点的可达情况。我们把这个单独的节点称为“子网路由器”。为了使子网路由器能够处理整个子网的AODV协议，子网路由器必须为整个子网维护一个目的地址序列数。在任何一条子网路由器发出的RREP消息中，RREP消息的前缀尺寸（Prefix Size）域必须被设置为子网前缀的长度。同一子网中的其他节点不应该发出RREP消息，并且应该把RREQ消息转发给子网路由器。


对于路由进入子网（也就是前缀长度非零）的RREP消息的处理与对指定目的主机的RREP消息的处理是一样的。接收到具有前缀尺寸域信息的每一个节点都应该为子网建立或者更新路由表项，这包括子网路由器所提供的序列数，以及适当的前驱节点的信息。这样，以后节点就可以使用这个路由表项的信息来避免向相同子网的其他节点继续发送RREQ消息了。
当节点使用子网路由时，一个包可能会被路由到子网中的一个IP地址，但这个IP地址没有为任何ad hoc网络中现存的节点所使用。如果这种情况发生了，子网路由器必须向发送消息的节点返回ICMP 主机不可达（Host Unreachable）消息。接收到了这条ICMP消息的上游节点应该记录不可达的这个特殊的IP地址，但是一定不能把任何匹配的子网前缀的路由表项变成无效。
如果同时有几个子网中的节点都能够向子网前缀域中所定义的子网广播其可达性，那么具有最低IP地址的节点就会被选为子网路由器，而其他的所有节点必须停止广播其可达性。
默认路由（也就是路由前缀为0的路由）的行为在这里没有定义。选择具有共同前缀位的路由应该遵照最长匹配优先原则。

8.AODV在其他网络中的应用
在某些网络配置中，ad hoc网络可能能够在不使用AODV的外部路由区域间提供连接。对于在外部路由区域中的任何相关网络，如果与其他网络连接的点能够像子网路由器（见第七章）一样工作，那么ad hoc网络就能够在外部路由区域间保持连接。实际上，外部路由网络可以将AODV所定义的ad hoc网络像传送网络（transit network）来使用。
为了提供这一特性，外部网络的连接点（称之为基础路由器）需要像子网路由器一样工作。对于外部网络中的每一个子网来说，基础路由器都能够提供可达性。这需要为外部子网维护一个目的地址序列数。

9.扩展

本部分对RREQ和RREP消息的扩展形式做了具体的说明。所有这些扩展都出现在消息数据之后，并有下面的形式：
	
    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     类型      |    长度     |     类型相关的数据 ...
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

	这里：

	类型	1——255

	长度	类型相关的数据的长度，不包括以字节形式表示的扩展的类型和长度域。

	类型号在128到255之间的扩展不能被跳过。扩展的规则将在下面更全面的论述出来，而且与处理IPv6的规则一致。

9.1.消息中的Hello间隔扩展格式

    0                   1                   2                   3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   |     类型      |    长度     |       Hello Interval ...        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
   | ... Hello Interval续        |
   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-

	类型	1

	长度	4

	Hello Interval
			连续发送一个Hello消息的间隔间毫秒的数量。
10.参数配置

本部分给出了一些与AODV协议操作相关的重要参数的默认值。某些特定的移动节点可能会需要改变这些参数中的一些，特别是NET_DIAMETER，MY_ROUTE_TIMEOUT，ALLOWED_HELLO_LOSS，RREQ_RETRIES，以及HELLO_INTERVAL。在后面的例子中，节点将会在它的Hello消息中，通过向RREP消息中附加Hello Interval扩展信息，来广播HELLO_INTERVAL。这些参数的选择可能会影响到协议的性能。改变NODE_TRAVERSAL_TIME还会改变节点对NET_TRAVERSAL_TIME参数的估计，因此只能够在了解ad hoc子网中其他节点的行为时才能做出改动。对于MY_ROUTE_TIMEOUT的值的设定必须至少是PATH_DISCOVERY_TIME的2倍。

参数名称           	取值
   ----------------------   -----
   ACTIVE_ROUTE_TIMEOUT     3,000毫秒
   ALLOWED_HELLO_LOSS       2
   BLACKLIST_TIMEOUT        RREQ_RETRIES * NET_TRAVERSAL_TIME
   DELETE_PERIOD            见下面说明
   HELLO_INTERVAL           1,000毫秒
   LOCAL_ADD_TTL            2
   MAX_REPAIR_TTL           0.3 * NET_DIAMETER
   MIN_REPAIR_TTL           见下面说明
   MY_ROUTE_TIMEOUT         2 * ACTIVE_ROUTE_TIMEOUT
   NET_DIAMETER             35
   NET_TRAVERSAL_TIME       2 * NODE_TRAVERSAL_TIME * NET_DIAMETER
   NEXT_HOP_WAIT            NODE_TRAVERSAL_TIME + 10
   NODE_TRAVERSAL_TIME      40毫秒
   PATH_DISCOVERY_TIME      2 * NET_TRAVERSAL_TIME
   RERR_RATELIMIT           10
   RING_TRAVERSAL_TIME      2 * NODE_TRAVERSAL_TIME *
                            (TTL_VALUE + TIMEOUT_BUFFER)
   RREQ_RETRIES             2
   RREQ_RATELIMIT           10
   TIMEOUT_BUFFER           2
   TTL_START                1
   TTL_INCREMENT            2
   TTL_THRESHOLD            7
   TTL_VALUE                见下面说明

MIN_REPAIR_TTL应该是最近得到的关于目的节点的跳数。如果使用了Hello消息，那么ACTIVE_ROUTE_TIMEOUT参数的值就必须大于ALLOWED_HELLO_LOSS * HELLO_INTERVAL的值。对于一个给定的ACTIVE_ROUTE_TIMEOUT值，这或许就需要调整HELLO_INTERVAL的值，也就因此需要调整Hello消息中Interval Extension的使用。

TTL_VALUE是当进行扩展环路搜寻时，IP头中TTL域的值。这一点在6.4部分中有进一步的说明。TIMEOUT_BUFFER是可以设置的。设置它的目的是为超时提供一个缓冲区，这样如果由于网络拥塞RREP消息被延迟了，当RREP仍然在返回发起节点的路径上时，超时就不大可能会发生。如果想忽略这个缓冲区的话，可以设置TIMEOUT_BUFFER为0。

设置DELETE_PERIOD参数的目的是为下面这种情况提供一个时间上界，即一个以D为目的节点的上游节点A有一个邻居节点B作为活动的下一跳，而B已经把它到D的路由设置为无效了。当超出这个时间以后B节点就可以删除这条（已经无效的）到D的路径了。这个时间上界的取值某种程度上取决于下层链路层的特性。如果Hello Message被用来探测到下一跳节点的后续连接状况的话，DELETE_PERIOD至少要为ALLOWED_HELLO_LOSS *HELLO_INTERVAL。如果链路层反馈被用来检测连接的丢失，DELETE_PERIOD至少要为ACTIVE_ROUTE_TIMEOUT。如果从一个邻居处能够接收到Hello Message而到这个邻居的数据包却丢失了（也就是由于暂时的连接不对称），我们就必须对下层的链路层做出更具体的假设。我们假设这个不对称状况只能持续一段时间，也就是HELLO_INTERVAL的K倍。换句话说，如果连接可用，而且邻居节点没有进行其他的网络流量，这个节点将会在K个Hello Message中至少接收到其中的一个。考虑到所有的可能情况，

DELETE_PERIOD = K * max (ACTIVE_ROUTE_TIMEOUT, HELLO_INTERVAL)
				（推荐K=5）

NET_DIAMETER测量的是网络中两个节点间的最大可能跳数。NODE_TRAVERSAL_TIME是关于数据包平均一跳传送时间的保守估计，它应该包括队列延迟，中断处理时间和传送时间。如果使用了链路层的指标（indications）来检测像IEEE 802.11 [5]标准中的连接中断，ACTIVE_ROUTE_TIMEOUT应该被设置为一个稍长的时间（至少10，000毫秒）。如果Hello Message被用在本地连接信息上的话，TTL_START应该被设置为至少为2。AODV协议的性能

对这些常量的取值很敏感，而这些常量常常取决于下面链路层协议的特性，以及采用的无线电技术。如果使用了扩展环路探查，BLACKLIST_TIMEOUT应该被适当地增加。在这些情况里，它应改为{[(TTL_THRESHOLD - TTL_START)/TTL_INCREMENT] + 1 + RREQ_RETRIES} *NET_TRAVERSAL_TIME。这是考虑到可能出现的额外路由发现请求时的取值。

11.安全性考虑

目前，AODV没有采取任何特殊的安全手段。然而，路由协议是扮演攻击的首要目标。在节点组成未知的网络中，很难判断扮演攻击是否发生，就算是安全防御技术也是很难判断的。但是，如果网络成员已知，而且可能会发生这种攻击，就必须使用认证技术（authentication techniques）来保护AODV控制消息，例如使用带有无遗忘且加密了的强消息摘要，或者使用数字签名。虽然AODV没有对为此目的而使用何种认证机制做出限制，但是对于节点共享适度的使用AH安全保证（appropriate security association）的情况来说，IPsec AH是一个合适的选择。

	特别地，RREP消息应该被认证，以防出现到某个所请求的目的地址的伪造路由。否则，攻击者就可以化装成为所请求的目的地址，而且故意拒绝到目的地址的请求，以及/或者故意检查并消费本来应该是发送到目的节点的流量。RRER消息虽然没有这么危险，但是也应该被认证，以防恶意节点破坏通信双方节点之间可行的路由。

	对于移动节点使用哪个IP地址，AODV没有对此做出任何假设，除非已经设定它们有了一个单独的IP地址。因此，除了由于普遍的协议说明而出现的很自然的考虑以外，对于IPsec认证头或者密钥交换机制的可用性来说，AODV没有做出特别的考虑。然而，如果ad hoc网络中的移动节点已经预设了安全保证，我们就要假定建立安全保证的目的包括了对AODV控制消息的认证化处理。有了这个理解以后，移动节点就能够使用基于其IP地址的认证机制，这个认证机制与不使用它时所使用的机制相同。


12.IANA(网络号码分配)考虑

	对于发送到654端口的消息，AODV定义了一个“类型”域。对于这个类型域的值，我们设置了一个新的注册表项（registry），而且还设置了如下的值：

	消息类型                    	值
      ---------------------------   -----
      路由请求(RREQ)	           1
      路由答复(RREP)          	    2
      路由错误(RERR)              	3
      路由答复的应答(RREP-ACK)       4	

	AODV控制信息可以具有扩展项。目前只定义了一个扩展项。对于扩展项的类型域，我们建立了一个新的注册表项：

	扩展类型                  	值
      ---------------------------   -----
      Hello Interval                 1

	未来要设置消息类型或者扩展类型的值可以通过使用标准规定[2]来分配。

13.IPv6考虑

IPv6的详细操作参见[6]。对于协议的唯一改动之处是地址域被扩大了。

14.致谢

特别感谢UCSB（加州大学圣芭芭拉分校）的Ian Chakeres，这是因为他对最近版本的广泛建议和贡献。

	我们感谢Carl Gunter小组在宾夕法尼亚大学，斯坦福大学和卡内基梅隆大学所做的工作，即试验某些情况（特别是含有重启和丢失RRER消息）下的AODV，在这些情况下，以前版本的AODV会出现路由环路。对这些成就的贡献者包括Karthikeyan，Bhargavan，Joshua Broch，Dave Maltz，Madanlal Musuvathi和Davor Obradovic。DELETE_PERIOD参数，设置它的意思是到一个特定目的节点的过期路由（特别是序列数）必须要维护，也是他们提出的。

	我们还要感谢Sung-Ju Lee（特别是关于本地修复的部分），Mahesh Marina，Erik Nordstrom （他提供了6.11部分的文本），Yves Prelot, Marc Mosko，Manel Guerrero Zapata，Philippe Jacquet，和Fred Baker所做出的注释和改进。



15.标准类参考文献

[1]	Bradner, S. "Key words for use in RFCs to Indicate Requirement Levels", BCP 14, RFC 2119, March 1997.

[2]	Narten, T. and H. Alvestrand, "Guidelines for Writing an IANA Considerations Section in RFCs", BCP 26, RFC 2434, October 1998.

16.信息类参考文献

[3]	Manner, J., et al., "Mobility Related Terminology", Work in Progress, July 2001.

[4]	Karthikeyan Bhargavan, Carl A. Gunter, and Davor Obradovic. Fault Origin Adjudication.In Proceedings of the Workshop on Formal Methods in Software Practice, Portland, OR, August 2000.

[5]	IEEE 802.11 Committee, AlphaGraphics #35, 10201 N.35th Avenue,Phoenix AZ 85051.  Wireless LAN Medium Access Control MAC and Physical Layer PHY Specifications, June 1997.  IEEE Standard 802.11-97.

[6]	Perkins, C., Royer, E. and S. Das, "Ad hoc on demand distance vector (AODV) routing for ip version 6", Work in Progress.



17.作者地址

   	Charles E. Perkins
   	通信系统实验室
   	诺基亚研发中心
   	313 Fairchild Drive
   	Mountain View, 加利福尼亚州 94303
   	美利坚合众国

   	电话: +1 650 625 2986
   	传真: +1 650 691 2170 (fax)
  	 电子邮件: Charles.Perkins@nokia.com

   	Elizabeth M. Belding-Royer
   	计算机科学系
   	加州大学圣芭芭拉分校
   	圣芭芭拉, 加利福尼亚州 93106

   	电话: +1 805 893 3411
   	传真: +1 805 893 8553
   	电子邮件: ebelding@cs.ucsb.edu

   	Samir R. Das
   	电气工程与计算机科学与工程系
  	辛辛那提大学
   	辛辛那提, 俄亥俄州 45221-0030

   	电话: +1 513 556 2594
   	传真: +1 513 556 7326
电子邮件: sdas@ececs.uc.edu



18.完整版权申明

版权归国际互联网协会（2003）所有。保留所有权利。

	本文档和其翻译可以拷贝并提供给他人；对于它的评论，或者对它的解释，或者对其实现进行协助的衍生性工作均可以制作、拷贝并发布，只要以上的版权声明和本段落均包含在这些拷贝和衍生性工作里。然而，不能够以任何方式改动本文档，比如删除对国际互联网协会或者其他组织的版权声明或引用，除非是为了扩展互联网标准（在这种情况下，必须遵从因特网标准版权制定流程），或者将本文翻译成英语以外的文字。

	以上所授予的有限权限是永久性的，不会为国际互联网协会或其后继者所撤销。
	
鸣谢
RFC编辑者的资金目前是由国际互联网协会所提供的。


